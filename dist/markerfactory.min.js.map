{"version":3,"file":"markerfactory.min.js","sources":["../src/markerfactory.js"],"sourcesContent":["function compact(array) {\n    let index = -1,\n        length = array ? array.length : 0,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n        let value = array[index];\n        if (value) {\n            result[resIndex++] = value;\n        }\n    }\n    return result;\n}\n\nfunction padHex(str_in) {\n    if (('' + str_in).length === 1) {\n        return '0' + String(str_in);\n    } else {\n        return String(str_in);\n    }\n}\n\nconst defaults = {\n    h: 1,\n    s: 78, // constant saturation\n    l: 63, // constant luminance\n    a: 1\n};\n\nfunction hslaString(hslcolor) {\n    if (hslcolor.a) {\n        return 'hsla(' + hslcolor.h + ',' + hslcolor.s + '%,' + hslcolor.l + '%,' + hslcolor.a + ')';\n    }\n    return 'hsl(' + hslcolor.h + ',' + hslcolor.s + '%,' + hslcolor.l + '%)';\n}\n\nfunction rgbaString(hexcolor) {\n    if (hexcolor.a) {\n        return 'rgba(' + hexcolor.r + ',' + hexcolor.g + ',' + hexcolor.b + ',' + hexcolor.a + ')';\n    }\n    return 'rgb(' + hexcolor.r + ',' + hexcolor.g + ',' + hexcolor.b + ')';\n}\n\nfunction getColor(val, range) {\n    defaults.h = Math.floor((360 / range) * val);\n    return hslaString(defaults);\n}\n\nfunction getColor1() {\n    const defaults1 = {\n        h: 1,\n        s: 78, // constant saturation\n        l: 33, // constant luminance\n        a: 1\n    };\n    return hslaString(defaults1);\n}\n\nfunction parseHalf(foo) {\n    return parseInt(foo / 2, 10);\n}\n\n\nfunction darken(stringcolor, factor) {\n    const darkercolor = {};\n    if (!factor) {\n        factor = 1;\n    }\n    if (stringcolor.fillColor.indexOf('rgb') !== -1) {\n        darkercolor.r = factor * parseHalf(stringcolor.r);\n        darkercolor.g = factor * parseHalf(stringcolor.g);\n        darkercolor.b = factor * parseHalf(stringcolor.b);\n        darkercolor.a = 0.99;\n        darkercolor.fillColor = rgbaString(darkercolor);\n    } else if (stringcolor.fillColor.indexOf('hsl') !== -1) {\n        darkercolor.h = stringcolor.h;\n        darkercolor.s = stringcolor.s;\n        darkercolor.l = factor * stringcolor.l - 30;\n        darkercolor.fillColor = hslaString(darkercolor);\n    }\n\n    return darkercolor;\n}\n\n\nfunction parseHex(hexstring, opacity, darkenfactor) {\n    let hexcolor = {\n        hex: hexstring\n    };\n    darkenfactor = darkenfactor || 1;\n\n    hexstring = hexstring.replace('#', '');\n    if (hexstring.length === 3) {\n        hexstring = hexstring[0] + hexstring[0] + hexstring[1] + hexstring[1] + hexstring[2] + hexstring[2];\n    }\n    if (isNaN(parseFloat(opacity, 10))) {\n        opacity = 1;\n    }\n\n    hexcolor.r = parseInt(darkenfactor * (parseInt(hexstring.substring(0, 2), 16)), 10);\n    hexcolor.g = parseInt(darkenfactor * (parseInt(hexstring.substring(2, 4), 16)), 10);\n    hexcolor.b = parseInt(darkenfactor * (parseInt(hexstring.substring(4, 6), 16)), 10);\n    hexcolor.a = opacity;\n    hexcolor.fillColor = rgbaString(hexcolor);\n    hexcolor.strokeColor = [\n        'rgba(' + parseHalf(hexcolor.r),\n        parseHalf(hexcolor.g),\n        parseHalf(hexcolor.b), hexcolor.a + ')'\n    ].join(',');\n    hexcolor.rgb = hexcolor.fillColor;\n    return hexcolor;\n}\n\n\nfunction parseHSL(hslstring, opacity) {\n    let hslcolor = {},\n        hslcolor_stroke = {},\n        hslparts = compact(hslstring.split(/hsla?\\(|,|\\)|%/));\n\n    if (hslparts[3] === undefined) {\n        hslparts[3] = 1;\n    }\n    if (isNaN(parseFloat(opacity, 10))) {\n        opacity = 1;\n    }\n\n    hslcolor.h = hslcolor_stroke.h = parseFloat(hslparts[0], 10);\n    hslcolor.s = hslcolor_stroke.s = parseFloat(hslparts[1], 10);\n    hslcolor.l = parseFloat(hslparts[2], 10);\n    hslcolor.a = hslcolor_stroke.a = parseFloat(opacity * hslparts[3], 10);\n    hslcolor_stroke.l = parseInt(hslcolor.l / 2, 10);\n\n\n    hslcolor.fillColor = hslaString(hslcolor);\n    hslcolor.strokeColor = hslaString(hslcolor_stroke);\n    hslcolor.hsl = hslcolor.fillColor;\n    return hslcolor;\n}\n\nfunction parseRGB(rgbstring, opacity, darkenfactor) {\n    let rgbcolor = {},\n        rgbparts = compact(rgbstring.split(/rgba?\\(|,|\\)/));\n\n    darkenfactor = darkenfactor || 1;\n\n    if (rgbparts[3] === undefined) {\n        rgbparts[3] = 1;\n    }\n\n    if (isNaN(parseFloat(opacity, 10))) {\n        opacity = 1;\n    }\n\n    rgbcolor.r = parseInt(darkenfactor * (parseInt(rgbparts[0], 10) % 256), 10);\n    rgbcolor.g = parseInt(darkenfactor * (parseInt(rgbparts[1], 10) % 256), 10);\n    rgbcolor.b = parseInt(darkenfactor * (parseInt(rgbparts[2], 10) % 256), 10);\n    rgbcolor.a = parseFloat(opacity * rgbparts[3], 10);\n    rgbcolor.fillColor = rgbaString(rgbcolor);\n    rgbcolor.strokeColor = 'rgba(' + rgbcolor.r / 2 + ',' + rgbcolor.g / 2 + ',' + rgbcolor.b / 2 + ',' + rgbcolor.a + ')';\n    rgbcolor.rgb = rgbcolor.fillColor;\n    return rgbcolor;\n}\n\nfunction toDecColor(stringcolor) {\n    let parsedcolor = {};\n    if (!stringcolor) {\n        parsedcolor.fillColor = 'rgba(100,250,50,0.99)';\n    } else if (stringcolor.indexOf('rgb') !== -1) {\n        parsedcolor = parseRGB(stringcolor);\n    } else if (stringcolor.indexOf('hsl') !== -1) {\n        parsedcolor = parseHSL(stringcolor);\n    } else {\n        parsedcolor = parseHex(stringcolor);\n    }\n\n    return parsedcolor;\n}\n\n\nfunction getColors(options) {\n    let color0, color1;\n    if (options.index !== undefined && options.count > 0) {\n        color0 = getColor(options.index, options.count);\n        color1 = getColor1();\n    } else {\n        let deccolor = toDecColor(options.color);\n        color0 = deccolor.fillColor;\n        color1 = darken(deccolor).fillColor;\n    }\n    return [color0, color1];\n}\n\n\nfunction rgbToHSL(r, g, b, a) {\n    r = (r % 256) / 255;\n    g = (g % 256) / 255;\n    b = (b % 256) / 255;\n    if (a === undefined) {\n        a = 1;\n    }\n    let max = Math.max(r, g, b),\n        min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2;\n\n    if (max === min) {\n        h = s = 0; // achromatic\n    } else {\n        let d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n        case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n        case g:\n            h = (b - r) / d + 2;\n            break;\n        case b:\n            h = (r - g) / d + 4;\n            break;\n        default:\n            h = 0;\n            break;\n        }\n\n        h /= 6;\n    }\n    let hsl = {\n        h: Math.round(360 * h),\n        s: Math.round(100 * s),\n        l: Math.round(100 * l),\n        a: Math.round(100 * a) / 100\n    };\n\n    hsl.fillColor = hslaString(hsl);\n\n    return hsl;\n}\n\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\n\nfunction hslToRGB(h, s, l, a, darkenfactor) {\n    let r, g, b;\n\n    darkenfactor = darkenfactor || 1;\n    h = parseFloat(h, 10) / 360;\n    s = parseFloat(s, 10) / 100;\n    l = parseFloat(l, 10) / 100;\n    if (a === undefined) {\n        a = 1;\n    }\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n\n\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        let p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    if (a === undefined) {\n        a = 1;\n    }\n\n    let rgb = {\n        r: Math.round(r * 255 * darkenfactor),\n        g: Math.round(g * 255 * darkenfactor),\n        b: Math.round(b * 255 * darkenfactor),\n        a: parseFloat(a, 10)\n    };\n\n    rgb.fillColor = rgbaString(rgb);\n\n    return rgb;\n\n}\n\n\nfunction IconObject(canvas, markerOpts) {\n    this.url = canvas.toDataURL();\n    this.fillColor = canvas.fillColor;\n    this.markerOpts = markerOpts;\n    Object.assign(this, markerOpts);\n    return this;\n};\nIconObject.prototype.toJSON = function () {\n    return {\n        url: null,\n        markerOpts: this.markerOpts\n    };\n};\n\nfunction createTextMarker(theoptions) {\n\n    const generateCanvas = function (options) {\n        let canvas = document.createElement(\"canvas\");\n        let ancho = 30,\n            alto = 40;\n        canvas.width = ancho + 18;\n        canvas.height = alto;\n        let x = canvas.width / 2,\n            y = canvas.height - 2,\n            radius = ancho / 2,\n            angulo = 0.6;\n\n        let font = \"'\" + options.font + \"'\" || 'Arial';\n        let fontsize = options.fontsize || 11;\n\n        let context = canvas.getContext(\"2d\");\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        let radius0 = 2 * radius,\n            cx = x + 0.95 * radius0,\n            cy = y + 0.45 * radius0;\n\n        let grad = context.createLinearGradient(0, 0, 0, canvas.height),\n            colors = getColors(options),\n            color0 = colors[0],\n            color1 = colors[1];\n\n        grad.addColorStop(0, color0);\n        grad.addColorStop(1, color1);\n\n        context.fillStyle = grad;\n        context.strokeStyle = 'rgba(200,200,200,0.7)';\n\n        context.beginPath();\n\n        //arco izquierdo\n        context.arc(cx - 1, cy, radius0, 9 * Math.PI / 8, -6 * Math.PI / 8, false);\n\n        // arco superior\n        context.arc(x, (y - 7) / 2, radius, angulo, Math.PI - angulo, true);\n\n        //arco derecho\n        context.arc(2 * x - cx + 1, cy, radius0, -0.95 * Math.PI / 3, -Math.PI / 8, false);\n        context.fill();\n        context.stroke();\n\n        context.beginPath();\n        context.arc(x, 0.40 * y, 2 * radius / 3, 0, 2 * Math.PI, false);\n        context.fillStyle = 'white';\n        context.fill();\n\n        context.beginPath();\n\n        // Render Label\n        //context.font = \"11pt Arial\";\n        context.font = fontsize + \"pt \" + font;\n        context.textBaseline = \"top\";\n\n        let textWidth = context.measureText(options.label);\n\n        if (textWidth.width > ancho || String(options.label).length > 3) {\n            context.rect(x - 2 - textWidth.width / 2, y - 30, x - 2 + textWidth.width / 2, y - 23);\n            context.fillStyle = '#F7F0F0';\n            context.fill();\n            context.stroke();\n        }\n\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        // centre the text.\n        context.fillText(options.label, 1 + Math.floor((canvas.width / 2) - (textWidth.width / 2)), 8);\n\n        return canvas;\n\n    };\n    theoptions.scale = theoptions.scale || 0.75;\n    let markerCanvas = generateCanvas(theoptions),\n        markerOpts = {};\n\n    theoptions.type = 'textmarker';\n\n    Object.assign(markerOpts, theoptions);\n\n    if (window && window.google && window.google.maps) {\n        Object.assign(markerOpts, {\n            size: new google.maps.Size(48, 40),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(24 * theoptions.scale, 40 * theoptions.scale),\n            scaledSize: new google.maps.Size(48 * theoptions.scale, 40 * theoptions.scale)\n        });\n    }\n    let iconObj = new IconObject(markerCanvas, markerOpts);\n\n    return iconObj;\n}\n\n\nfunction createClusterIcon(theoptions) {\n\n    const generateClusterCanvas = function (options) {\n        let canvas = options.canvas || document.createElement(\"canvas\"),\n            anchorX = 27,\n            anchorY = 53,\n            radius = (anchorX - 9),\n            angulo = 1.1,\n            font = options.font || 'fontello',\n            fontsize = options.fontsize || 14,\n            context = canvas.getContext(\"2d\"),\n            grad = context.createLinearGradient(0, 0, 0, anchorY);\n\n        canvas.width = anchorX * 2;\n        canvas.height = anchorY + 1;\n\n        let colors = getColors(options),\n            color0 = colors[0],\n            color1 = colors[1];\n\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        context.moveTo(anchorX, anchorY);\n\n        let labelvalue = parseInt(options.label, 10);\n        if (labelvalue < 10) {\n            color1 = 'orange';\n            fontsize = 14;\n        } else if (labelvalue < 30) {\n            color1 = 'red';\n            fontsize = 15;\n        } else {\n            color1 = 'purple';\n            fontsize = 16;\n        }\n        if (labelvalue > 99) {\n            radius = radius + 3;\n            context.setLineDash([5, 5]);\n            context.beginPath();\n            context.arc(anchorX, 2 + (0.50 * anchorY), (radius + 7), 0, 2 * Math.PI, false);\n            context.fillStyle = 'transparent';\n            context.strokeStyle = color1;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n        }\n\n        context.setLineDash([5, 5]);\n        context.beginPath();\n        context.arc(anchorX, 2 + (0.50 * anchorY), (radius + 2), 0, 2 * Math.PI, false);\n        context.fillStyle = 'transparent';\n        context.strokeStyle = color1;\n        context.lineWidth = 2;\n        context.fill();\n        context.stroke();\n\n        // Círculo blanco\n        context.setLineDash([5, 0]);\n        context.beginPath();\n        context.arc(anchorX, 2 + (0.50 * anchorY), (radius - 3), 0, 2 * Math.PI, false);\n        context.fillStyle = 'white';\n        context.strokeStyle = color1;\n        context.lineWidth = 4;\n        context.fill();\n        context.stroke();\n\n        context.beginPath();\n\n        context.font = 'normal normal normal ' + fontsize + 'px ' + font;\n        console.log('context font', context.font);\n        context.fillStyle = '#333';\n        context.textBaseline = \"top\";\n\n\n        let textWidth = context.measureText(options.label),\n            text_x = options.label,\n            label_x = Math.floor((canvas.width / 2) - (textWidth.width / 2)),\n            label_y = 1 + Math.floor(canvas.height / 2 - fontsize / 2);\n\n        // centre the text.\n        context.fillText(text_x, label_x, label_y);\n\n        return canvas;\n\n    };\n    theoptions.scale = theoptions.scale || 1;\n    let markerCanvas = generateClusterCanvas(theoptions),\n        markerOpts = {},\n        scale = theoptions.scale;\n\n    Object.assign(markerOpts, theoptions);\n\n    if (window && window.google && window.google.maps) {\n        Object.assign(markerOpts, {\n            size: new google.maps.Size(54, 48),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(27 * scale, 24 * scale),\n            scaledSize: new google.maps.Size(54 * scale, 48 * scale)\n        });\n    }\n\n    let iconObj = new IconObject(markerCanvas, markerOpts);\n\n    return iconObj;\n}\n\nfunction createFatMarkerIcon(theoptions) {\n\n    const generateFatCanvas = function (options) {\n        let canvas = options.canvas || document.createElement(\"canvas\"),\n            anchorX = 27,\n            anchorY = 53,\n            radius = (anchorX - 9),\n            angulo = 1.1,\n            font = options.font || 'fontello',\n            fontsize = options.fontsize || 14,\n            context = canvas.getContext(\"2d\"),\n            grad = context.createLinearGradient(0, 0, 0, anchorY);\n\n        canvas.width = anchorX * 2;\n        canvas.height = anchorY + 1;\n\n        let colors = getColors(options),\n            color0 = colors[0],\n            color1 = colors[1];\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        grad.addColorStop(0, color0);\n        grad.addColorStop(1, color1);\n\n        context.fillStyle = grad;\n        context.strokeStyle = color1;\n        context.beginPath();\n\n        context.moveTo(anchorX, anchorY);\n\n        // arco superior\n        context.arc(anchorX, 2 + (0.50 * anchorY), radius, angulo, Math.PI - angulo, true);\n\n        //punta inferior\n        context.lineTo(anchorX, anchorY);\n\n        context.fill();\n        context.stroke();\n\n        // Círculo blanco\n        context.beginPath();\n        context.arc(anchorX, 2 + (0.50 * anchorY), (radius - 3), 0, 2 * Math.PI, false);\n        context.fillStyle = 'white';\n        context.fill();\n\n        context.beginPath();\n\n        context.font = 'normal normal normal ' + fontsize + 'px ' + font;\n        //console.log('context font', context.font);\n        context.fillStyle = color1;\n        context.textBaseline = \"top\";\n\n        let textWidth = context.measureText(options.unicodelabel),\n            text_x = options.unicodelabel,\n            label_x = Math.floor((canvas.width / 2) - (textWidth.width / 2)),\n            label_y = 1 + Math.floor(canvas.height / 2 - fontsize / 2);\n\n        // centre the text.\n        context.fillText(text_x, label_x, label_y);\n        canvas.fillColor = color0;\n        return canvas;\n    };\n\n    let scale = theoptions.scale || 1,\n        markerCanvas = generateFatCanvas(theoptions),\n        markerOpts = {};\n\n    theoptions.type = 'fatmarker';\n\n    Object.assign(markerOpts, theoptions);\n\n    if (window && window.google && window.google.maps) {\n        Object.assign(markerOpts, {\n            size: new google.maps.Size(54, 48),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(21 * scale, 36 * scale),\n            scaledSize: new google.maps.Size(42 * scale, 36 * scale),\n            scale: scale\n        });\n    }\n    let iconObj = new IconObject(markerCanvas, markerOpts);\n    return iconObj;\n}\n\nfunction createTransparentMarkerIcon(theoptions) {\n\n    const generateTransparentCanvas = function (options) {\n        let text_x,\n            canvas = options.canvas || document.createElement(\"canvas\"),\n            context = canvas.getContext(\"2d\"),\n            font = options.font || 'fontello',\n            fontsize = options.fontsize || 26;\n\n        canvas.width = 54;\n        canvas.height = 48;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        let colors = getColors(options),\n            color0 = colors[0],\n            color1 = colors[1];\n        context.beginPath();\n\n        if (options.shadow) {\n\n            context.font = 'normal normal normal ' + fontsize + 'px ' + font;\n\n            context.textBaseline = \"top\";\n            let textWidth = context.measureText(options.unicodelabel);\n            text_x = Math.floor((canvas.width / 2) - (textWidth.width / 2));\n\n            context.shadowOffsetX = -2;\n            context.shadowOffsetY = -2;\n            context.shadowBlur = 0;\n\n            context.fillStyle = '#FFFFFF';\n            context.shadowColor = '#666666';\n\n            context.fillText(options.unicodelabel, text_x - 4, 2);\n            context.fillText(options.unicodelabel, text_x, 5);\n            context.fillStyle = color0;\n            context.fillText(options.unicodelabel, text_x + 4, 8);\n\n            context.strokeStyle = '#FFFFFF';\n            context.strokeText(options.unicodelabel, text_x + 4, 8);\n\n        } else {\n\n            context.font = 'normal normal normal ' + (fontsize - 3) + 'px ' + font;\n\n            context.textBaseline = \"top\";\n            let textmetric = context.measureText(options.unicodelabel);\n            text_x = Math.floor((canvas.width / 2) - (textmetric.width / 2));\n\n            //console.debug('textmetric', textmetric);\n\n            context.shadowOffsetX = 2;\n            context.shadowOffsetY = 2;\n            context.shadowBlur = 0;\n            context.shadowColor = '#FFFFFF';\n            context.fillStyle = color0;\n            context.fillText(options.unicodelabel, text_x + 1, 6);\n\n            context.shadowOffsetX = 2;\n            context.shadowOffsetY = 2;\n            context.shadowBlur = 1;\n            context.shadowColor = '#FFFFFF';\n            context.strokeStyle = color1;\n            context.strokeText(options.unicodelabel, text_x + 1, 6);\n\n        }\n\n        canvas.fillColor = color0;\n\n        return canvas;\n\n    };\n\n    theoptions.scale = theoptions.scale || 1;\n    theoptions.fontsize = theoptions.fontsize || 26;\n\n    let markerCanvas = generateTransparentCanvas(theoptions),\n        markerOpts = {};\n\n    let scale = theoptions.scale;\n    /*if (theoptions.shadow) {\n        scale = 0.9 * scale;\n    }*/\n    theoptions.type = 'transparent';\n\n    Object.assign(markerOpts, theoptions);\n\n    if (window.google && window.google.maps) {\n        Object.assign(markerOpts, {\n            size: new google.maps.Size(54 * scale, 48 * scale),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(27 * scale, 24 * scale),\n            scaledSize: new google.maps.Size(54 * scale, 48 * scale)\n        });\n    }\n    let iconObj = new IconObject(markerCanvas, markerOpts);\n\n    return iconObj;\n};\n\n\nconst MarkerFactory = {\n    createTransparentMarkerIcon: createTransparentMarkerIcon,\n    createFatMarkerIcon: createFatMarkerIcon,\n    createTextMarker: createTextMarker,\n    /**\n     * Receives a color string rgb(a), hsl(a) or hex, returns its components\n     * in rgba and hsla, with optional transparency\n     * plus a darkened version (default is half of each RGB component) and a\n     *\n     * @param {string} somecolor          - A color string in  rgb(a), hsl(a) or hex format\n     * @param {Number} [opacity=1]        - Opacity to apply to the color\n     * @param {Number} [darkenfactor=1] - How much darker should the resulting color be\n     *\n     * @return     {Object}  input color parsed and modified as requested\n     */\n    parseColorString: function (somecolor, opacity, darkenfactor) {\n        let parsedcolor = {\n                original: somecolor\n            },\n            hsl, rgb;\n\n        darkenfactor = darkenfactor || 1;\n        opacity = opacity || 1;\n\n        if (somecolor.indexOf('hsl') !== -1) {\n            hsl = parseHSL(somecolor, opacity);\n            rgb = hslToRGB(hsl.h, hsl.s, hsl.l, hsl.a, darkenfactor);\n\n        } else if (somecolor.indexOf('rgb') !== -1) {\n            rgb = parseRGB(somecolor, opacity, darkenfactor);\n        } else {\n            rgb = parseHex(somecolor, opacity, darkenfactor);\n        }\n\n\n        hsl = rgbToHSL(rgb.r, rgb.g, rgb.b, rgb.a);\n\n\n        parsedcolor.hsl = {\n            h: hsl.h,\n            s: hsl.s,\n            l: hsl.l,\n            a: hsl.a\n        };\n        parsedcolor.rgb = {\n            r: rgb.r,\n            g: rgb.g,\n            b: rgb.b,\n            a: rgb.a\n        };\n\n\n        parsedcolor.fillColor = rgb.fillColor;\n        parsedcolor.rgba = rgb.fillColor;\n        parsedcolor.hsla = hsl.fillColor;\n        parsedcolor.strokeColor = rgb.strokeColor;\n        parsedcolor.hex = ['#', padHex(rgb.r.toString(16)), padHex(rgb.g.toString(16)), padHex(rgb.b.toString(16))].join('');\n        return parsedcolor;\n    },\n    /**\n     * Generates an google maps marker (or an image as dataurl from the given options)\n     *\n     * @param      {Object}  options  The options\n     * @return     {Object}  { description_of_the_return_value }\n     */\n    autoIcon: function (options) {\n\n        if (typeof (options) !== 'object') {\n            console.warn('autoIcon expects an object as its only parameter');\n            return null;\n        }\n\n        options.label = String(options.label || 'A');\n        options.color = options.color || '#FF0000';\n\n        // unless explicitly set to false, the icon doesn't have a marker-like wrapper\n        if (options.transparent_background === undefined) {\n            options.transparent_background = true;\n        }\n\n        if (options.label.length === 4 || options.label.substring(0, 2) === '0x') {\n\n\n            options.font = options.font || 'fontello';\n            options.label = (options.label || 'e836').slice(-4);\n            options.unicodelabel = String.fromCharCode('0x' + options.label);\n            options.scale = options.scale || 1;\n\n            if (options.transparent_background) {\n                console.log('createTransparentMarkerIcon', options.font);\n                return MarkerFactory.createTransparentMarkerIcon(options);\n            } else {\n                console.log('createFatMarkerIcon', options.font);\n                return MarkerFactory.createFatMarkerIcon(options);\n            }\n        } else if (options.shadow) {\n            return createClusterIcon(options);\n        } else {\n            options.scale = options.scale || 0.75;\n            options.label = String(options.label || 'A');\n            options.fontsize = options.fontsize || 11;\n            options.font = options.font || 'Arial';\n            // This is text I should print literally\n            return MarkerFactory.createTextMarker(options);\n        }\n\n    }\n};\n\n\nexport {\n    MarkerFactory\n};\nexport default MarkerFactory;"],"names":["compact","array","index","length","resIndex","result","value","padHex","str_in","String","hslaString","hslcolor","a","h","s","l","rgbaString","hexcolor","r","g","b","parseHalf","foo","parseInt","parseHex","hexstring","opacity","darkenfactor","hex","replace","isNaN","parseFloat","substring","fillColor","strokeColor","join","rgb","parseHSL","hslstring","hslcolor_stroke","hslparts","split","undefined","hsl","parseRGB","rgbstring","rgbcolor","rgbparts","getColors","options","color0","color1","count","val","range","defaults","Math","floor","getColor","deccolor","stringcolor","parsedcolor","indexOf","toDecColor","color","factor","darkercolor","darken","hue2rgb","p","q","t","IconObject","canvas","markerOpts","this","url","toDataURL","Object","assign","prototype","toJSON","MarkerFactory","createTransparentMarkerIcon","theoptions","scale","fontsize","markerCanvas","text_x","document","createElement","context","getContext","font","width","height","clearRect","colors","beginPath","shadow","textBaseline","textWidth","measureText","unicodelabel","shadowOffsetX","shadowOffsetY","shadowBlur","fillStyle","shadowColor","fillText","strokeStyle","strokeText","textmetric","generateTransparentCanvas","type","window","google","maps","size","Size","origin","Point","anchor","scaledSize","createFatMarkerIcon","grad","createLinearGradient","anchorX","anchorY","addColorStop","moveTo","arc","PI","lineTo","fill","stroke","label_x","label_y","generateFatCanvas","createTextMarker","ancho","x","y","cx","cy","label","rect","generateCanvas","parseColorString","somecolor","original","round","hslToRGB","max","min","d","rgbToHSL","rgba","hsla","toString","autoIcon","console","warn","transparent_background","slice","fromCharCode","radius","labelvalue","setLineDash","lineWidth","generateClusterCanvas","createClusterIcon"],"mappings":"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"}